*** Map.cpp.old	2011-10-23 17:12:07.772700000 +0200
--- Map.cpp	2011-12-06 20:55:48.424550000 +0100
***************
*** 219,227 ****
--- 219,232 ----
          }
      }
  
+     for (std::map<uint32, DynamicLOSObject*>::iterator i = m_dynamicLOSObjects.begin(); i != m_dynamicLOSObjects.end(); ++i)
+         delete i->second;
+ 
      //lets initialize visibility distance for map
      Map::InitVisibilityDistance();
  
+     m_dynamicLOSCounter = 0;
+ 
      sScriptMgr->OnCreateMap(this);
  }
--- 271,290 ----
      }
  
      Cell cell(p);
      if (!IsGridLoaded(GridCoord(cell.data.Part.grid_x, cell.data.Part.grid_y)))
          return;
  
      sLog->outStaticDebug("Switch object " UI64FMTD " from grid[%u, %u] %u", obj->GetGUID(), cell.data.Part.grid_x, cell.data.Part.grid_y, on);
      NGridType *ngrid = getNGrid(cell.GridX(), cell.GridY());
      ASSERT(ngrid != NULL);
  
      GridType &grid = ngrid->GetGridType(cell.CellX(), cell.CellY());
  
+     obj->RemoveFromGrid(); 
      if (on)
          grid.AddWorldObject<T>(obj);
      else
          grid.AddGridObject<T>(obj);
      obj->m_isWorldObject = on;
  }
--- 380,401 ----
      EnsureGridLoaded(Cell(x, y));
  }
  
! bool Map::AddPlayerToMap(Player* player)
  {
!     CellCoord cellCoord = Trinity::ComputeCellCoord(player->GetPositionX(), player->GetPositionY());
!     if (!cellCoord.IsCoordValid())
      {
!         sLog->outError("Map::Add: Player (GUID: %u) has invalid coordinates X:%f Y:%f grid cell [%u:%u]", player->GetGUIDLow(), player->GetPositionX(), player->GetPositionY(), cellCoord.x_coord, cellCoord.y_coord);
          return false;
      }
  
!     Cell cell(cellCoord);
      EnsureGridLoadedForActiveObject(cell, player);
      AddToGrid(player, cell);
  
+     // Check if we are adding to correct map
+     ASSERT (player->GetMap() == this);
+     player->SetMap(this);
      player->AddToWorld();
  
      SendInitSelf(player);
--- 420,476 ----
  }
  
  template<class T>
! bool Map::AddToMap(T *obj)
  {
!     //TODO: Needs clean up. An object should not be added to map twice.
!     if (obj->IsInWorld())
      {
!         ASSERT(obj->IsInGrid());
!         obj->UpdateObjectVisibility(true);
!         return true;
      }
  
!     CellCoord cellCoord = Trinity::ComputeCellCoord(obj->GetPositionX(), obj->GetPositionY());
!     //It will create many problems (including crashes) if an object is not added to grid after creation
!     //The correct way to fix it is to make AddToMap return false and delete the object if it is not added to grid
!     //But now AddToMap is used in too many places, I will just see how many ASSERT failures it will cause
!     ASSERT(cellCoord.IsCoordValid());
!     if (!cellCoord.IsCoordValid())
      {
!         sLog->outError("Map::Add: Object " UI64FMTD " has invalid coordinates X:%f Y:%f grid cell [%u:%u]", obj->GetGUID(), obj->GetPositionX(), obj->GetPositionY(), cellCoord.x_coord, cellCoord.y_coord);
!         return false; //Should delete object
      }
  
+     Cell cell(cellCoord);
      if (obj->isActiveObject())
          EnsureGridLoadedForActiveObject(cell, obj);
      else
          EnsureGridCreated(GridCoord(cell.GridX(), cell.GridY()));
      AddToGrid(obj, cell);
!     sLog->outStaticDebug("Object %u enters grid[%u, %u]", GUID_LOPART(obj->GetGUID()), cell.GridX(), cell.GridY());
! 
!     //Must already be set before AddToMap. Usually during obj->Create.
      //obj->SetMap(this);
      obj->AddToWorld();
+ 
      InitializeObject(obj);
  
      if (obj->isActiveObject())
          AddToActive(obj);
  
      //something, such as vehicle, needs to be update immediately
      //also, trigger needs to cast spell, if not update, cannot see visual
      obj->UpdateObjectVisibility(true);
+     return true;
***************
*** 2917,2919 ****
--- 2651,2801 ----
      if (m_mapRefIter == player->GetMapRef())
          m_mapRefIter = m_mapRefIter->nocheck_prev();
  }
+ uint32 Map::AddDynLOSObject(float x, float y, float radius)
+ {
+     DynamicLOSObject* obj = new DynamicLOSObject();
+     obj->SetCoordinates(x, y);
+     obj->SetRadius(radius);
+ 
+     // Add the dynamic object to the map
+     m_dynamicLOSObjects[++m_dynamicLOSCounter] = obj;
+ 
+     return m_dynamicLOSCounter;
+ }
+ 
+ uint32 Map::AddDynLOSObject(float x, float y, float z, float radius, float height)
+ {
+     DynamicLOSObject* obj = new DynamicLOSObject();
+     obj->SetCoordinates(x, y);
+     obj->SetZ(z);
+     obj->SetHeight(height);
+     obj->SetRadius(radius);
+ 
+     // Add the dynamic object to the map
+     m_dynamicLOSObjects[++m_dynamicLOSCounter] = obj;
+ 
+     return m_dynamicLOSCounter;
+ }
+ 
+ void Map::SetDynLOSObjectState(uint32 id, bool state)
+ {
+     std::map<uint32, DynamicLOSObject*>::iterator iter = m_dynamicLOSObjects.find(id);
+     if (iter != m_dynamicLOSObjects.end())
+         iter->second->SetActiveState(state);
+ }
+ 
+ bool Map::GetDynLOSObjectState(uint32 id)
+ {
+     std::map<uint32, DynamicLOSObject*>::iterator iter = m_dynamicLOSObjects.find(id);
+     if (iter != m_dynamicLOSObjects.end())
+         return (iter->second->IsActive());
+     return false;
+ }
+ 
+ bool Map::IsInDynLOS(float x, float y, float z, float x2, float y2, float z2)
+ {
+     if (!m_dynamicLOSCounter)
+         return true;
+ 
+     for (std::map<uint32, DynamicLOSObject*>::iterator iter = m_dynamicLOSObjects.begin(); iter != m_dynamicLOSObjects.end(); ++iter)
+         if (iter->second->IsActive() && iter->second->IsBetween(x, y, z, x2, y2, z2))
+             return false;
+ 
+     return true;
+ }
+ 
+ DynamicLOSObject::DynamicLOSObject()
+ {
+     _x = 0.0f;
+     _y = 0.0f;
+     _z = 0.0f;
+     _height = 0.0f;
+     _radius = 0.0f;
+     _active = false;
+ }
+ 
+ bool DynamicLOSObject::IsBetween(float x, float y, float z, float x2, float y2, float z2)
+ {
+     if (IsInside(x, y) || IsInside(x2, y2))
+     {
+         if(HasHeightInfo() && IsOverOrUnder(z2))
+             return false;
+ 
+         return true;
+     }
+ 
+     // For a real handling of Z coord is necessary to do some research from this point
+     // i.e. A player over a huge round plattaform, placed near the edge; and other player placed  down the plattaform at the oposing extreme just next to the edge;
+     // both may be able to attack each other, even when the plattaform height should prevent that.
+     if ((std::max(x, x2) < (_x - _radius))
+         || (std::min(x, x2) > (_x + _radius))
+         || (std::max(y, y2) < (_y - _radius))
+         || (std::min(y, y2) > (_y + _radius)))
+         return false;
+ 
+ 
+     float angleToMe = atan2(_x - x, _y - y);
+     angleToMe = (angleToMe >= 0) ? angleToMe : 2 * M_PI + angleToMe;
+ 
+     float angleToDest = atan2(x2 - x, y2 - y);
+     angleToDest = (angleToDest >= 0) ? angleToDest : 2 * M_PI + angleToDest;
+ 
+     return (fabs(sin(angleToMe - angleToDest)) * GetDistance(x, y) < _radius);
+ }
+ 
+ bool DynamicLOSObject::IsInside(float x, float y)
+ {
+     return (((x-_x)*(x-_x)+(y-_y)*(y-_y))<(_radius*_radius));
+ }
+ 
+ bool DynamicLOSObject::IsOverOrUnder(float z)
+ {
+     return ((z < _z+_height) && (z > _z));
+ }
+ 
+ float DynamicLOSObject::GetDistance(float x, float y)
+ {
+     return sqrtf((x-_x)*(x-_x)+(y-_y)*(y-_y));
+ }
+ 
+ bool DynamicLOSObject::IsActive()
+ {
+     return _active;
+ }
+ 
+ void DynamicLOSObject::SetActiveState(bool state)
+ {
+     _active = state;
+ }
+ 
+ void DynamicLOSObject::SetCoordinates(float x, float y)
+ {
+     _x = x;
+     _y = y;
+ }
+ 
+ void DynamicLOSObject::SetRadius(float r)
+ {
+     _radius = r;
+ }
+ 
+ void DynamicLOSObject::SetZ(float z)
+ {
+     _z = z;
+ }
+ 
+ void DynamicLOSObject::SetHeight(float h)
+ {
+     _height = h;
+ }
+ 
+ bool DynamicLOSObject::HasHeightInfo()
+ {
+     return (_z != 0 || _height != 0);
+ }
